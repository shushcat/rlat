//! Generated by Snowball 2.2.0 - https://snowballstem.org/

package snowball

import(
  snowballRuntime "github.com/snowballstem/snowball/go"
)

var A_0 = []*snowballRuntime.Among{
    &snowballRuntime.Among{Str:"arsen", A:-1, B:-1, F:nil},
    &snowballRuntime.Among{Str:"commun", A:-1, B:-1, F:nil},
    &snowballRuntime.Among{Str:"gener", A:-1, B:-1, F:nil},
}

var A_1 = []*snowballRuntime.Among{
    &snowballRuntime.Among{Str:"'", A:-1, B:1, F:nil},
    &snowballRuntime.Among{Str:"'s'", A:0, B:1, F:nil},
    &snowballRuntime.Among{Str:"'s", A:-1, B:1, F:nil},
}

var A_2 = []*snowballRuntime.Among{
    &snowballRuntime.Among{Str:"ied", A:-1, B:2, F:nil},
    &snowballRuntime.Among{Str:"s", A:-1, B:3, F:nil},
    &snowballRuntime.Among{Str:"ies", A:1, B:2, F:nil},
    &snowballRuntime.Among{Str:"sses", A:1, B:1, F:nil},
    &snowballRuntime.Among{Str:"ss", A:1, B:-1, F:nil},
    &snowballRuntime.Among{Str:"us", A:1, B:-1, F:nil},
}

var A_3 = []*snowballRuntime.Among{
    &snowballRuntime.Among{Str:"", A:-1, B:3, F:nil},
    &snowballRuntime.Among{Str:"bb", A:0, B:2, F:nil},
    &snowballRuntime.Among{Str:"dd", A:0, B:2, F:nil},
    &snowballRuntime.Among{Str:"ff", A:0, B:2, F:nil},
    &snowballRuntime.Among{Str:"gg", A:0, B:2, F:nil},
    &snowballRuntime.Among{Str:"bl", A:0, B:1, F:nil},
    &snowballRuntime.Among{Str:"mm", A:0, B:2, F:nil},
    &snowballRuntime.Among{Str:"nn", A:0, B:2, F:nil},
    &snowballRuntime.Among{Str:"pp", A:0, B:2, F:nil},
    &snowballRuntime.Among{Str:"rr", A:0, B:2, F:nil},
    &snowballRuntime.Among{Str:"at", A:0, B:1, F:nil},
    &snowballRuntime.Among{Str:"tt", A:0, B:2, F:nil},
    &snowballRuntime.Among{Str:"iz", A:0, B:1, F:nil},
}

var A_4 = []*snowballRuntime.Among{
    &snowballRuntime.Among{Str:"ed", A:-1, B:2, F:nil},
    &snowballRuntime.Among{Str:"eed", A:0, B:1, F:nil},
    &snowballRuntime.Among{Str:"ing", A:-1, B:2, F:nil},
    &snowballRuntime.Among{Str:"edly", A:-1, B:2, F:nil},
    &snowballRuntime.Among{Str:"eedly", A:3, B:1, F:nil},
    &snowballRuntime.Among{Str:"ingly", A:-1, B:2, F:nil},
}

var A_5 = []*snowballRuntime.Among{
    &snowballRuntime.Among{Str:"anci", A:-1, B:3, F:nil},
    &snowballRuntime.Among{Str:"enci", A:-1, B:2, F:nil},
    &snowballRuntime.Among{Str:"ogi", A:-1, B:13, F:nil},
    &snowballRuntime.Among{Str:"li", A:-1, B:15, F:nil},
    &snowballRuntime.Among{Str:"bli", A:3, B:12, F:nil},
    &snowballRuntime.Among{Str:"abli", A:4, B:4, F:nil},
    &snowballRuntime.Among{Str:"alli", A:3, B:8, F:nil},
    &snowballRuntime.Among{Str:"fulli", A:3, B:9, F:nil},
    &snowballRuntime.Among{Str:"lessli", A:3, B:14, F:nil},
    &snowballRuntime.Among{Str:"ousli", A:3, B:10, F:nil},
    &snowballRuntime.Among{Str:"entli", A:3, B:5, F:nil},
    &snowballRuntime.Among{Str:"aliti", A:-1, B:8, F:nil},
    &snowballRuntime.Among{Str:"biliti", A:-1, B:12, F:nil},
    &snowballRuntime.Among{Str:"iviti", A:-1, B:11, F:nil},
    &snowballRuntime.Among{Str:"tional", A:-1, B:1, F:nil},
    &snowballRuntime.Among{Str:"ational", A:14, B:7, F:nil},
    &snowballRuntime.Among{Str:"alism", A:-1, B:8, F:nil},
    &snowballRuntime.Among{Str:"ation", A:-1, B:7, F:nil},
    &snowballRuntime.Among{Str:"ization", A:17, B:6, F:nil},
    &snowballRuntime.Among{Str:"izer", A:-1, B:6, F:nil},
    &snowballRuntime.Among{Str:"ator", A:-1, B:7, F:nil},
    &snowballRuntime.Among{Str:"iveness", A:-1, B:11, F:nil},
    &snowballRuntime.Among{Str:"fulness", A:-1, B:9, F:nil},
    &snowballRuntime.Among{Str:"ousness", A:-1, B:10, F:nil},
}

var A_6 = []*snowballRuntime.Among{
    &snowballRuntime.Among{Str:"icate", A:-1, B:4, F:nil},
    &snowballRuntime.Among{Str:"ative", A:-1, B:6, F:nil},
    &snowballRuntime.Among{Str:"alize", A:-1, B:3, F:nil},
    &snowballRuntime.Among{Str:"iciti", A:-1, B:4, F:nil},
    &snowballRuntime.Among{Str:"ical", A:-1, B:4, F:nil},
    &snowballRuntime.Among{Str:"tional", A:-1, B:1, F:nil},
    &snowballRuntime.Among{Str:"ational", A:5, B:2, F:nil},
    &snowballRuntime.Among{Str:"ful", A:-1, B:5, F:nil},
    &snowballRuntime.Among{Str:"ness", A:-1, B:5, F:nil},
}

var A_7 = []*snowballRuntime.Among{
    &snowballRuntime.Among{Str:"ic", A:-1, B:1, F:nil},
    &snowballRuntime.Among{Str:"ance", A:-1, B:1, F:nil},
    &snowballRuntime.Among{Str:"ence", A:-1, B:1, F:nil},
    &snowballRuntime.Among{Str:"able", A:-1, B:1, F:nil},
    &snowballRuntime.Among{Str:"ible", A:-1, B:1, F:nil},
    &snowballRuntime.Among{Str:"ate", A:-1, B:1, F:nil},
    &snowballRuntime.Among{Str:"ive", A:-1, B:1, F:nil},
    &snowballRuntime.Among{Str:"ize", A:-1, B:1, F:nil},
    &snowballRuntime.Among{Str:"iti", A:-1, B:1, F:nil},
    &snowballRuntime.Among{Str:"al", A:-1, B:1, F:nil},
    &snowballRuntime.Among{Str:"ism", A:-1, B:1, F:nil},
    &snowballRuntime.Among{Str:"ion", A:-1, B:2, F:nil},
    &snowballRuntime.Among{Str:"er", A:-1, B:1, F:nil},
    &snowballRuntime.Among{Str:"ous", A:-1, B:1, F:nil},
    &snowballRuntime.Among{Str:"ant", A:-1, B:1, F:nil},
    &snowballRuntime.Among{Str:"ent", A:-1, B:1, F:nil},
    &snowballRuntime.Among{Str:"ment", A:15, B:1, F:nil},
    &snowballRuntime.Among{Str:"ement", A:16, B:1, F:nil},
}

var A_8 = []*snowballRuntime.Among{
    &snowballRuntime.Among{Str:"e", A:-1, B:1, F:nil},
    &snowballRuntime.Among{Str:"l", A:-1, B:2, F:nil},
}

var A_9 = []*snowballRuntime.Among{
    &snowballRuntime.Among{Str:"succeed", A:-1, B:-1, F:nil},
    &snowballRuntime.Among{Str:"proceed", A:-1, B:-1, F:nil},
    &snowballRuntime.Among{Str:"exceed", A:-1, B:-1, F:nil},
    &snowballRuntime.Among{Str:"canning", A:-1, B:-1, F:nil},
    &snowballRuntime.Among{Str:"inning", A:-1, B:-1, F:nil},
    &snowballRuntime.Among{Str:"earring", A:-1, B:-1, F:nil},
    &snowballRuntime.Among{Str:"herring", A:-1, B:-1, F:nil},
    &snowballRuntime.Among{Str:"outing", A:-1, B:-1, F:nil},
}

var A_10 = []*snowballRuntime.Among{
    &snowballRuntime.Among{Str:"andes", A:-1, B:-1, F:nil},
    &snowballRuntime.Among{Str:"atlas", A:-1, B:-1, F:nil},
    &snowballRuntime.Among{Str:"bias", A:-1, B:-1, F:nil},
    &snowballRuntime.Among{Str:"cosmos", A:-1, B:-1, F:nil},
    &snowballRuntime.Among{Str:"dying", A:-1, B:3, F:nil},
    &snowballRuntime.Among{Str:"early", A:-1, B:9, F:nil},
    &snowballRuntime.Among{Str:"gently", A:-1, B:7, F:nil},
    &snowballRuntime.Among{Str:"howe", A:-1, B:-1, F:nil},
    &snowballRuntime.Among{Str:"idly", A:-1, B:6, F:nil},
    &snowballRuntime.Among{Str:"lying", A:-1, B:4, F:nil},
    &snowballRuntime.Among{Str:"news", A:-1, B:-1, F:nil},
    &snowballRuntime.Among{Str:"only", A:-1, B:10, F:nil},
    &snowballRuntime.Among{Str:"singly", A:-1, B:11, F:nil},
    &snowballRuntime.Among{Str:"skies", A:-1, B:2, F:nil},
    &snowballRuntime.Among{Str:"skis", A:-1, B:1, F:nil},
    &snowballRuntime.Among{Str:"sky", A:-1, B:-1, F:nil},
    &snowballRuntime.Among{Str:"tying", A:-1, B:5, F:nil},
    &snowballRuntime.Among{Str:"ugly", A:-1, B:8, F:nil},
}

var G_aeo = []byte{17, 64}

var G_v = []byte{17, 65, 16, 1}

var G_v_WXY = []byte{1, 17, 65, 208, 1}

var G_valid_LI = []byte{55, 141, 2}

type Context struct {
    b_Y_found bool
    i_p2 int
    i_p1 int
}

func r_prelude(env *snowballRuntime.Env, ctx interface{}) bool {
    context := ctx.(*Context)
    _ = context
    context.b_Y_found = false
    var v_1 = env.Cursor
    lab0: for {
        env.Bra = env.Cursor
        if !env.EqS("'") {
            break lab0
        }
        env.Ket = env.Cursor
        if !env.SliceDel() {
            return false
        }
        break lab0
    }
    env.Cursor = v_1
    var v_2 = env.Cursor
    lab1: for {
        env.Bra = env.Cursor
        if !env.EqS("y") {
            break lab1
        }
        env.Ket = env.Cursor
        if !env.SliceFrom("Y") {
            return false
        }
        context.b_Y_found = true
        break lab1
    }
    env.Cursor = v_2
    var v_3 = env.Cursor
    lab2: for {
        replab3: for{
            var v_4 = env.Cursor
            lab4: for _ = range [2]struct{}{} {
                golab5: for {
                    var v_5 = env.Cursor
                    lab6: for {
                        if !env.InGrouping(G_v, 97, 121) {
                            break lab6
                        }
                        env.Bra = env.Cursor
                        if !env.EqS("y") {
                            break lab6
                        }
                        env.Ket = env.Cursor
                        env.Cursor = v_5
                        break golab5
                    }
                    env.Cursor = v_5
                    if env.Cursor >= env.Limit {
                        break lab4
                    }
                    env.NextChar();
                }
                if !env.SliceFrom("Y") {
                    return false
                }
                context.b_Y_found = true
                continue replab3
            }
            env.Cursor = v_4
            break replab3
        }
        break lab2
    }
    env.Cursor = v_3
    return true
}

func r_mark_regions(env *snowballRuntime.Env, ctx interface{}) bool {
    context := ctx.(*Context)
    _ = context
    context.i_p1 = env.Limit
    context.i_p2 = env.Limit
    var v_1 = env.Cursor
    lab0: for {
        lab1: for {
            var v_2 = env.Cursor
            lab2: for {
                if env.FindAmong(A_0, context) == 0 {
                    break lab2
                }
                break lab1
            }
            env.Cursor = v_2
            golab3: for {
                lab4: for {
                    if !env.InGrouping(G_v, 97, 121) {
                        break lab4
                    }
                    break golab3
                }
                if env.Cursor >= env.Limit {
                    break lab0
                }
                env.NextChar();
            }
            golab5: for {
                lab6: for {
                    if !env.OutGrouping(G_v, 97, 121) {
                        break lab6
                    }
                    break golab5
                }
                if env.Cursor >= env.Limit {
                    break lab0
                }
                env.NextChar();
            }
            break lab1
        }
        context.i_p1 = env.Cursor
        golab7: for {
            lab8: for {
                if !env.InGrouping(G_v, 97, 121) {
                    break lab8
                }
                break golab7
            }
            if env.Cursor >= env.Limit {
                break lab0
            }
            env.NextChar();
        }
        golab9: for {
            lab10: for {
                if !env.OutGrouping(G_v, 97, 121) {
                    break lab10
                }
                break golab9
            }
            if env.Cursor >= env.Limit {
                break lab0
            }
            env.NextChar();
        }
        context.i_p2 = env.Cursor
        break lab0
    }
    env.Cursor = v_1
    return true
}

func r_shortv(env *snowballRuntime.Env, ctx interface{}) bool {
    context := ctx.(*Context)
    _ = context
    lab0: for {
        var v_1 = env.Limit - env.Cursor
        lab1: for {
            if !env.OutGroupingB(G_v_WXY, 89, 121) {
                break lab1
            }
            if !env.InGroupingB(G_v, 97, 121) {
                break lab1
            }
            if !env.OutGroupingB(G_v, 97, 121) {
                break lab1
            }
            break lab0
        }
        env.Cursor = env.Limit - v_1
        if !env.OutGroupingB(G_v, 97, 121) {
            return false
        }
        if !env.InGroupingB(G_v, 97, 121) {
            return false
        }
        if env.Cursor > env.LimitBackward {
            return false
        }
        break lab0
    }
    return true
}

func r_R1(env *snowballRuntime.Env, ctx interface{}) bool {
    context := ctx.(*Context)
    _ = context
    return context.i_p1 <= env.Cursor
}

func r_R2(env *snowballRuntime.Env, ctx interface{}) bool {
    context := ctx.(*Context)
    _ = context
    return context.i_p2 <= env.Cursor
}

func r_Step_1a(env *snowballRuntime.Env, ctx interface{}) bool {
    context := ctx.(*Context)
    _ = context
    var among_var int32
    var v_1 = env.Limit - env.Cursor
    lab0: for {
        env.Ket = env.Cursor
        if env.FindAmongB(A_1, context) == 0 {
            env.Cursor = env.Limit - v_1
            break lab0
        }
        env.Bra = env.Cursor
        if !env.SliceDel() {
            return false
        }
        break lab0
    }
    env.Ket = env.Cursor
    among_var = env.FindAmongB(A_2, context)
    if among_var == 0 {
        return false
    }
    env.Bra = env.Cursor
    switch among_var {
    case 1:
        if !env.SliceFrom("ss") {
            return false
        }
    case 2:
        lab1: for {
            var v_2 = env.Limit - env.Cursor
            lab2: for {
                if !env.HopBack(2) {
                    break lab2
                }
                if !env.SliceFrom("i") {
                    return false
                }
                break lab1
            }
            env.Cursor = env.Limit - v_2
            if !env.SliceFrom("ie") {
                return false
            }
            break lab1
        }
    case 3:
        if env.Cursor <= env.LimitBackward {
            return false
        }
        env.PrevChar();
        golab3: for {
            lab4: for {
                if !env.InGroupingB(G_v, 97, 121) {
                    break lab4
                }
                break golab3
            }
            if env.Cursor <= env.LimitBackward {
                return false
            }
            env.PrevChar();
        }
        if !env.SliceDel() {
            return false
        }
    }
    return true
}

func r_Step_1b(env *snowballRuntime.Env, ctx interface{}) bool {
    context := ctx.(*Context)
    _ = context
    var among_var int32
    env.Ket = env.Cursor
    among_var = env.FindAmongB(A_4, context)
    if among_var == 0 {
        return false
    }
    env.Bra = env.Cursor
    switch among_var {
    case 1:
        if !r_R1(env, context) {
            return false
        }
        if !env.SliceFrom("ee") {
            return false
        }
    case 2:
        var v_1 = env.Limit - env.Cursor
        golab0: for {
            lab1: for {
                if !env.InGroupingB(G_v, 97, 121) {
                    break lab1
                }
                break golab0
            }
            if env.Cursor <= env.LimitBackward {
                return false
            }
            env.PrevChar();
        }
        env.Cursor = env.Limit - v_1
        if !env.SliceDel() {
            return false
        }
        env.Ket = env.Cursor
        env.Bra = env.Cursor
        var v_3 = env.Limit - env.Cursor
        among_var = env.FindAmongB(A_3, context)
        switch among_var {
        case 1:
            if !env.SliceFrom("e") {
                return false
            }
            return false
        case 2:
            var v_4 = env.Limit - env.Cursor
            lab2: for {
                if !env.InGroupingB(G_aeo, 97, 111) {
                    break lab2
                }
                if env.Cursor > env.LimitBackward {
                    break lab2
                }
                return false
            }
            env.Cursor = env.Limit - v_4
        case 3:
            if env.Cursor != context.i_p1 {
                return false
            }
            var v_5 = env.Limit - env.Cursor
            if !r_shortv(env, context) {
                return false
            }
            env.Cursor = env.Limit - v_5
            if !env.SliceFrom("e") {
                return false
            }
            return false
        }
        env.Cursor = env.Limit - v_3
        env.Ket = env.Cursor
        if env.Cursor <= env.LimitBackward {
            return false
        }
        env.PrevChar();
        env.Bra = env.Cursor
        if !env.SliceDel() {
            return false
        }
    }
    return true
}

func r_Step_1c(env *snowballRuntime.Env, ctx interface{}) bool {
    context := ctx.(*Context)
    _ = context
    env.Ket = env.Cursor
    lab0: for {
        var v_1 = env.Limit - env.Cursor
        lab1: for {
            if !env.EqSB("y") {
                break lab1
            }
            break lab0
        }
        env.Cursor = env.Limit - v_1
        if !env.EqSB("Y") {
            return false
        }
        break lab0
    }
    env.Bra = env.Cursor
    if !env.OutGroupingB(G_v, 97, 121) {
        return false
    }
    lab2: for {
        if env.Cursor > env.LimitBackward {
            break lab2
        }
        return false
    }
    if !env.SliceFrom("i") {
        return false
    }
    return true
}

func r_Step_2(env *snowballRuntime.Env, ctx interface{}) bool {
    context := ctx.(*Context)
    _ = context
    var among_var int32
    env.Ket = env.Cursor
    among_var = env.FindAmongB(A_5, context)
    if among_var == 0 {
        return false
    }
    env.Bra = env.Cursor
    if !r_R1(env, context) {
        return false
    }
    switch among_var {
    case 1:
        if !env.SliceFrom("tion") {
            return false
        }
    case 2:
        if !env.SliceFrom("ence") {
            return false
        }
    case 3:
        if !env.SliceFrom("ance") {
            return false
        }
    case 4:
        if !env.SliceFrom("able") {
            return false
        }
    case 5:
        if !env.SliceFrom("ent") {
            return false
        }
    case 6:
        if !env.SliceFrom("ize") {
            return false
        }
    case 7:
        if !env.SliceFrom("ate") {
            return false
        }
    case 8:
        if !env.SliceFrom("al") {
            return false
        }
    case 9:
        if !env.SliceFrom("ful") {
            return false
        }
    case 10:
        if !env.SliceFrom("ous") {
            return false
        }
    case 11:
        if !env.SliceFrom("ive") {
            return false
        }
    case 12:
        if !env.SliceFrom("ble") {
            return false
        }
    case 13:
        if !env.EqSB("l") {
            return false
        }
        if !env.SliceFrom("og") {
            return false
        }
    case 14:
        if !env.SliceFrom("less") {
            return false
        }
    case 15:
        if !env.InGroupingB(G_valid_LI, 99, 116) {
            return false
        }
        if !env.SliceDel() {
            return false
        }
    }
    return true
}

func r_Step_3(env *snowballRuntime.Env, ctx interface{}) bool {
    context := ctx.(*Context)
    _ = context
    var among_var int32
    env.Ket = env.Cursor
    among_var = env.FindAmongB(A_6, context)
    if among_var == 0 {
        return false
    }
    env.Bra = env.Cursor
    if !r_R1(env, context) {
        return false
    }
    switch among_var {
    case 1:
        if !env.SliceFrom("tion") {
            return false
        }
    case 2:
        if !env.SliceFrom("ate") {
            return false
        }
    case 3:
        if !env.SliceFrom("al") {
            return false
        }
    case 4:
        if !env.SliceFrom("ic") {
            return false
        }
    case 5:
        if !env.SliceDel() {
            return false
        }
    case 6:
        if !r_R2(env, context) {
            return false
        }
        if !env.SliceDel() {
            return false
        }
    }
    return true
}

func r_Step_4(env *snowballRuntime.Env, ctx interface{}) bool {
    context := ctx.(*Context)
    _ = context
    var among_var int32
    env.Ket = env.Cursor
    among_var = env.FindAmongB(A_7, context)
    if among_var == 0 {
        return false
    }
    env.Bra = env.Cursor
    if !r_R2(env, context) {
        return false
    }
    switch among_var {
    case 1:
        if !env.SliceDel() {
            return false
        }
    case 2:
        lab0: for {
            var v_1 = env.Limit - env.Cursor
            lab1: for {
                if !env.EqSB("s") {
                    break lab1
                }
                break lab0
            }
            env.Cursor = env.Limit - v_1
            if !env.EqSB("t") {
                return false
            }
            break lab0
        }
        if !env.SliceDel() {
            return false
        }
    }
    return true
}

func r_Step_5(env *snowballRuntime.Env, ctx interface{}) bool {
    context := ctx.(*Context)
    _ = context
    var among_var int32
    env.Ket = env.Cursor
    among_var = env.FindAmongB(A_8, context)
    if among_var == 0 {
        return false
    }
    env.Bra = env.Cursor
    switch among_var {
    case 1:
        lab0: for {
            var v_1 = env.Limit - env.Cursor
            lab1: for {
                if !r_R2(env, context) {
                    break lab1
                }
                break lab0
            }
            env.Cursor = env.Limit - v_1
            if !r_R1(env, context) {
                return false
            }
            var v_2 = env.Limit - env.Cursor
            lab2: for {
                if !r_shortv(env, context) {
                    break lab2
                }
                return false
            }
            env.Cursor = env.Limit - v_2
            break lab0
        }
        if !env.SliceDel() {
            return false
        }
    case 2:
        if !r_R2(env, context) {
            return false
        }
        if !env.EqSB("l") {
            return false
        }
        if !env.SliceDel() {
            return false
        }
    }
    return true
}

func r_exception2(env *snowballRuntime.Env, ctx interface{}) bool {
    context := ctx.(*Context)
    _ = context
    env.Ket = env.Cursor
    if env.FindAmongB(A_9, context) == 0 {
        return false
    }
    env.Bra = env.Cursor
    if env.Cursor > env.LimitBackward {
        return false
    }
    return true
}

func r_exception1(env *snowballRuntime.Env, ctx interface{}) bool {
    context := ctx.(*Context)
    _ = context
    var among_var int32
    env.Bra = env.Cursor
    among_var = env.FindAmong(A_10, context)
    if among_var == 0 {
        return false
    }
    env.Ket = env.Cursor
    if env.Cursor < env.Limit {
        return false
    }
    switch among_var {
    case 1:
        if !env.SliceFrom("ski") {
            return false
        }
    case 2:
        if !env.SliceFrom("sky") {
            return false
        }
    case 3:
        if !env.SliceFrom("die") {
            return false
        }
    case 4:
        if !env.SliceFrom("lie") {
            return false
        }
    case 5:
        if !env.SliceFrom("tie") {
            return false
        }
    case 6:
        if !env.SliceFrom("idl") {
            return false
        }
    case 7:
        if !env.SliceFrom("gentl") {
            return false
        }
    case 8:
        if !env.SliceFrom("ugli") {
            return false
        }
    case 9:
        if !env.SliceFrom("earli") {
            return false
        }
    case 10:
        if !env.SliceFrom("onli") {
            return false
        }
    case 11:
        if !env.SliceFrom("singl") {
            return false
        }
    }
    return true
}

func r_postlude(env *snowballRuntime.Env, ctx interface{}) bool {
    context := ctx.(*Context)
    _ = context
    if !context.b_Y_found {
        return false
    }
    replab0: for{
        var v_1 = env.Cursor
        lab1: for _ = range [2]struct{}{} {
            golab2: for {
                var v_2 = env.Cursor
                lab3: for {
                    env.Bra = env.Cursor
                    if !env.EqS("Y") {
                        break lab3
                    }
                    env.Ket = env.Cursor
                    env.Cursor = v_2
                    break golab2
                }
                env.Cursor = v_2
                if env.Cursor >= env.Limit {
                    break lab1
                }
                env.NextChar();
            }
            if !env.SliceFrom("y") {
                return false
            }
            continue replab0
        }
        env.Cursor = v_1
        break replab0
    }
    return true
}

func Stem(env *snowballRuntime.Env) bool {
    var context =  &Context {
        b_Y_found: false,
        i_p2: 0,
        i_p1: 0,
    }
    _ = context
    lab0: for {
        var v_1 = env.Cursor
        lab1: for {
            if !r_exception1(env, context) {
                break lab1
            }
            break lab0
        }
        env.Cursor = v_1
        lab2: for {
            var v_2 = env.Cursor
            lab3: for {
                if !env.Hop(3) {
                    break lab3
                }
                break lab2
            }
            env.Cursor = v_2
            break lab0
        }
        env.Cursor = v_1
        r_prelude(env, context)
        r_mark_regions(env, context)
        env.LimitBackward = env.Cursor
        env.Cursor = env.Limit
        var v_5 = env.Limit - env.Cursor
        r_Step_1a(env, context)
        env.Cursor = env.Limit - v_5
        lab4: for {
            var v_6 = env.Limit - env.Cursor
            lab5: for {
                if !r_exception2(env, context) {
                    break lab5
                }
                break lab4
            }
            env.Cursor = env.Limit - v_6
            var v_7 = env.Limit - env.Cursor
            r_Step_1b(env, context)
            env.Cursor = env.Limit - v_7
            var v_8 = env.Limit - env.Cursor
            r_Step_1c(env, context)
            env.Cursor = env.Limit - v_8
            var v_9 = env.Limit - env.Cursor
            r_Step_2(env, context)
            env.Cursor = env.Limit - v_9
            var v_10 = env.Limit - env.Cursor
            r_Step_3(env, context)
            env.Cursor = env.Limit - v_10
            var v_11 = env.Limit - env.Cursor
            r_Step_4(env, context)
            env.Cursor = env.Limit - v_11
            var v_12 = env.Limit - env.Cursor
            r_Step_5(env, context)
            env.Cursor = env.Limit - v_12
            break lab4
        }
        env.Cursor = env.LimitBackward
        var v_13 = env.Cursor
        r_postlude(env, context)
        env.Cursor = v_13
        break lab0
    }
    return true
}
